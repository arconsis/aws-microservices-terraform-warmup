const { getUpdatedDocResponse } = require('../../common/utils');

const getWhereToFetchUser = ({
  id,
  userId,
  email,
  userName,
}) => ({
  ...(id && { id }),
  ...(userId && { userId }),
  ...(email && { email }),
  ...(userName && { userName }),
});

const getFieldsToUpdateUser = ({
  userName,
  profileImage,
  thumbnails,
}) => ({
  ...(userName && { userName }),
  ...(profileImage && { profileImage }),
  ...(thumbnails && { thumbnails }),
});

const userRepo = {
  async listUsers({
    attributes = [],
    limit = 50,
    offset = 0,
    orderBy = [
      ['createdAt', 'DESC'],
    ],
  }) {
    try {
      const {
        users: userModel,
      } = this.getDbModels();
      const list = await userModel.findAndCountAll({
        order: orderBy,
        attributes: attributes && Array.isArray(attributes) && attributes.length > 0
          ? attributes
          : { exclude: [] },
        limit,
        offset,
      });
      return {
        data: list && list.rows
          ? list.rows.map(el => el.get({ plain: true }))
          : [],
        pagination: {
          limit,
          offset,
          total: list && list.count
            ? list.count
            : 0,
        },
      };
    } catch (error) {
      throw error;
    }
  },
  async getUser({
    id,
    userId,
    email,
    userName,
    attributes = [],
    lock,
    transaction,
  }) {
    try {
      const {
        users: userModel,
      } = this.getDbModels();
      if (!id && !email && !userId && !userName) {
        throw new Error('Add id or email or userId or userName to get user.');
      }
      const res = await userModel.findOne({
        where: getWhereToFetchUser({
          id,
          userId,
          email,
          userName,
        }),
        attributes: attributes && Array.isArray(attributes) && attributes.length > 0
          ? attributes
          : { exclude: [] },
        ...(lock != null && { lock }),
        ...(transaction != null && { transaction }),
      });
      if (!res) {
        throw new Error('User doc not found.');
      }
      return res.get({ plain: true });
    } catch (error) {
      throw error;
    }
  },
  async createUser({
    firstName,
    lastName,
    userName,
    email,
    password,
    roles,
  }) {
    // https://github.com/sequelize/sequelize/issues/11541
    try {
      const {
        users: userModel,
      } = this.getDbModels();
      const db = this.getDB();
      const res = await userModel.create({
        firstName,
        lastName,
        userName,
        email,
        password,
        roles: db.literal(`ARRAY[${roles.map(v => `'${v}'`).join(',')}]::"enum_users_roles"[]`),
      });
      return res.get({ plain: true });
    } catch (error) {
      throw error;
    }
  },
  async updateUser({
    id,
    userId,
    userName,
    profileImage,
    thumbnails,
    lock,
    transaction,
  }) {
    try {
      const {
        users: userModel,
      } = this.getDbModels();
      if (!id && !userId) {
        throw new Error('Add id or or userIdto get user.');
      }
      const fieldsToUpdate = getFieldsToUpdateUser({
        userName,
        profileImage,
        thumbnails,
      });
      const res = await userModel.update(fieldsToUpdate, {
        where: getWhereToFetchUser({
          id,
          userId,
        }),
        returning: true,
        limit: 1,
        ...(lock != null && { lock }),
        ...(transaction != null && { transaction }),
      });
      return getUpdatedDocResponse(res, 'The user did not find.');
    } catch (error) {
      throw error;
    }
  }
};

module.exports = function init({
  users,
  sequelize,
}) {
  return Object.assign(Object.create(userRepo), {
    getDbModels() {
      return {
        users,
      };
    },
    getDB() {
      return sequelize;
    },
  });
};
